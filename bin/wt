#!/usr/bin/env bash
set -euo pipefail

VERSION="0.1.2"

show_help() {
  cat <<'EOF'
Usage: wt [command] [options]
Commands:
  <branch>                   Add a worktree (shorthand for 'wt add')
  list|ls                    Show active worktrees
  add [options] <branch>     Add a worktree; path defaults to ../<repo>-<branch>
  remove|rm <path|branch>    Remove a worktree by path or branch name
  prune                      Run git worktree prune
Options for add:
  -b, --base <branch>        Base branch (defaults to current branch)
  -p, --path <path>          Custom worktree path
  --no-copy                  Skip copying .worktreeinclude/.gitignore files
Examples:
  wt feature/login           Create branch from current, add worktree
  wt add -b main hotfix      Create hotfix from main
  wt add --no-copy feature   Skip file copying
  wt remove feature/login
Shell function (add to .bashrc/.zshrc for auto-cd):
  wt() { local p; p=$(command wt "$@") && [[ -d "$p" ]] && cd "$p" || echo "$p"; }
EOF
}

copy_worktree_files() {
  local src=$1 dest=$2
  local include="$src/.worktreeinclude" gitignore="$src/.gitignore"
  local patterns_file=""

  [[ -f "$include" ]] && patterns_file=$include
  [[ -z "$patterns_file" && -f "$gitignore" ]] && patterns_file=$gitignore
  [[ -z "$patterns_file" ]] && return 0

  while IFS= read -r pattern || [[ -n "$pattern" ]]; do
    [[ -z "$pattern" || "$pattern" =~ ^[#!] ]] && continue

    if [[ "$patterns_file" == "$include" && -f "$gitignore" ]] && ! grep -qFx "$pattern" "$gitignore"; then
      echo "wt: skipping '$pattern' (not in .gitignore)" >&2
      continue
    fi

    for file in "$src"/${pattern%/}; do
      [[ -e "$file" ]] || continue
      local relpath=${file#"$src/"}
      mkdir -p "$(dirname "$dest/$relpath")"
      cp -R "$file" "$dest/$relpath"
      echo "wt: copied $relpath"
    done
  done < "$patterns_file"
}

add_worktree() {
  local base="" path="" branch="" no_copy=false

  while [[ $# -gt 0 ]]; do
    case "$1" in
      -b|--base) base=$2; shift 2 ;;
      -p|--path) path=$2; shift 2 ;;
      --no-copy) no_copy=true; shift ;;
      -h|--help) show_help; exit 0 ;;
      *) [[ -z "$branch" ]] && branch=$1 || path=$1; shift ;;
    esac
  done

  [[ -z "$branch" ]] && { echo "wt add: branch name required" >&2; exit 1; }
  : "${path:=$(dirname "$repo_root")/${repo_name}-${branch//\//-}}"

  if git show-ref --verify --quiet "refs/heads/$branch"; then
    git worktree add "$path" "$branch" >&2
  elif git show-ref --verify --quiet "refs/remotes/origin/$branch"; then
    git worktree add --track -b "$branch" "$path" "origin/$branch" >&2
  else
    : "${base:=$(git branch --show-current)}"
    git worktree add -b "$branch" "$path" "$base" >&2
  fi

  [[ "$no_copy" == false ]] && copy_worktree_files "$repo_root" "$path" >&2
  echo "$path"
}

remove_worktree() {
  [[ $# -eq 0 ]] && { echo "wt remove: provide a path or branch name" >&2; exit 1; }

  local input=$1 target=""

  if [[ -d "$input" ]]; then
    target=$input
  else
    target=$(git worktree list --porcelain | awk -v b="$input" '/^worktree /{w=$2} /^branch /{gsub(/refs\/heads\//,"",$2); if($2==b){print w;exit}}')
    [[ -z "$target" ]] && guess="$(dirname "$repo_root")/${repo_name}-${input//\//-}" && [[ -d "$guess" ]] && target=$guess
  fi

  [[ -z "$target" ]] && { echo "wt remove: unable to resolve worktree for '$input'" >&2; exit 1; }
  git worktree remove "$target"
}

# Main
[[ $# -eq 0 || "$1" =~ ^(help|--help|-h)$ ]] && { show_help; exit 0; }
[[ "${1:-}" == "--version" ]] && { echo "wt $VERSION"; exit 0; }
git rev-parse --is-inside-work-tree >/dev/null 2>&1 || { echo "wt: run inside a git repository" >&2; exit 1; }

repo_root=$(git rev-parse --show-toplevel)
repo_name=$(basename "$repo_root")

cmd=$1
case "$cmd" in
  list|ls|prune|add|new|remove|rm) shift ;;
  *) cmd="add" ;;
esac

case "$cmd" in
  list|ls) git worktree list "$@" ;;
  prune)   git worktree prune "$@" ;;
  add|new) add_worktree "$@" ;;
  remove|rm) remove_worktree "$@" ;;
esac
